import numpy as np
import matplotlib.pyplot as plt
from collections import defaultdict
import json
from pathlib import Path

def _to_dhw(arr):
    if hasattr(arr, "values"):  # xarray
        arr = arr.values
    arr = np.asarray(arr)
    if arr.ndim == 2:
        return arr[None, ...].astype(np.float32)
    if arr.ndim != 3:
        raise ValueError(f"Expected 2D/3D array, got {arr.shape}")
    # HWD -> DHW if last dim looks like D
    if arr.shape[-1] in (32, 64, 128, 256, 512, 768, 1024) and arr.shape[0] not in (32, 64, 128, 256, 512, 768, 1024):
        arr = np.moveaxis(arr, -1, 0)
    return arr.astype(np.float32)

def _infer_should_flipud_from_meta(meta):
    """
    Infer whether image rows should be flipped to enforce north-up display.

    Returns:
      (should_flip: bool, reason: str)
    """
    if not isinstance(meta, dict):
        return False, "meta is not a dict"

    # If OutputSpec-level normalization has already been applied upstream,
    # do not auto-flip again in visualization.
    policy = str(meta.get("grid_orientation_policy", "")).strip().lower()
    if policy == "north_up":
        return False, "grid_orientation_policy=north_up (already normalized upstream)"
    if policy == "native":
        y_axis = str(meta.get("y_axis_direction", "")).strip().lower()
        if y_axis in {"south_to_north", "bottom_to_top"}:
            return True, f"grid_orientation_policy=native, y_axis_direction={y_axis}"
        if y_axis in {"north_to_south", "top_to_bottom"}:
            return False, f"grid_orientation_policy=native, y_axis_direction={y_axis}"

    # Highest-confidence signal: affine transform y-scale sign.
    # For north-up rasters, transform.e is typically negative.
    transform = meta.get("global_transform")
    if transform is not None and hasattr(transform, "e"):
        try:
            e = float(transform.e)
            if e > 0:
                return True, f"global_transform.e={e:.6g} (>0, south-up)"
            if e < 0:
                return False, f"global_transform.e={e:.6g} (<0, north-up)"
        except Exception:
            pass

    # Optional explicit metadata (if embedders add it in the future).
    y_axis = str(meta.get("y_axis_direction", "")).strip().lower()
    if y_axis in {"south_to_north", "bottom_to_top"}:
        return True, f"y_axis_direction={y_axis}"
    if y_axis in {"north_to_south", "top_to_bottom"}:
        return False, f"y_axis_direction={y_axis}"

    return False, "no orientation metadata; keep as-is"

def _robust_scale01(x, lo=2.0, hi=98.0, eps=1e-8):
    """Scale array to [0,1] with percentile clipping."""
    a = np.percentile(x, lo)
    b = np.percentile(x, hi)
    y = np.clip((x - a) / (b - a + eps), 0.0, 1.0)
    return y

def _stabilize_pca_sign(components: np.ndarray) -> np.ndarray:
    """
    Make PCA component signs deterministic.
    For each component row, enforce the element with max abs value to be positive.
    """
    comps = np.asarray(components, dtype=np.float32).copy()
    for i in range(comps.shape[0]):
        row = comps[i]
        if row.size == 0:
            continue
        j = int(np.argmax(np.abs(row)))
        if row[j] < 0:
            comps[i] = -row
    return comps

def fit_pca_rgb(
    emb,
    *,
    n_samples=100_000,
    seed=0,
    center=True,
):
    """
    Fit PCA on pixels of a (D,H,W) grid and return a dict with components for reuse.
    No sklearn dependency (uses SVD).
    """
    data = getattr(emb, "data", emb)
    dhw = _to_dhw(data)
    D, H, W = dhw.shape

    X = dhw.reshape(D, H * W).T  # [N, D]
    N = X.shape[0]

    rng = np.random.default_rng(seed)
    if n_samples is not None and N > n_samples:
        idx = rng.choice(N, size=int(n_samples), replace=False)
        Xs = X[idx]
    else:
        Xs = X

    # center
    mean = Xs.mean(axis=0) if center else np.zeros((D,), dtype=np.float32)
    Xc = Xs - mean

    # SVD for PCA
    # Xc = U S Vt, rows are samples
    # PCs are rows of Vt
    U, S, Vt = np.linalg.svd(Xc, full_matrices=False)
    comps = _stabilize_pca_sign(Vt[:3].astype(np.float32))  # [3, D]

    return {
        "mean": mean.astype(np.float32),
        "components": comps,
        "center": bool(center),
    }

def transform_pca_rgb(
    emb,
    pca,
    *,
    robust_lo=2.0,
    robust_hi=98.0,
):
    """
    Apply fitted PCA to emb, return rgb in [0,1] as (H,W,3).
    """
    data = getattr(emb, "data", emb)
    dhw = _to_dhw(data)
    D, H, W = dhw.shape

    X = dhw.reshape(D, H * W).T  # [N, D]
    mean = pca["mean"]
    comps = pca["components"]  # [3,D]

    Xc = X - mean if pca.get("center", True) else X
    Y = Xc @ comps.T  # [N,3]

    # robust scale each channel to [0,1]
    rgb = np.zeros_like(Y, dtype=np.float32)
    for k in range(3):
        rgb[:, k] = _robust_scale01(Y[:, k], lo=robust_lo, hi=robust_hi)

    return rgb.reshape(H, W, 3)

def plot_embedding_pseudocolor(
    emb,
    *,
    title=None,
    pca=None,
    n_samples=100_000,
    seed=0,
    robust_lo=2.0,
    robust_hi=98.0,
    figsize=(6, 5),
    show_colorbars=False,
    flipud=None,
    print_orientation=False,
):
    """
    Plot PCA pseudocolor image.
    If pca is None, fit PCA on this embedding.

    Args:
      flipud:
        - None (default): auto-detect from emb.meta (north-up alignment).
        - True/False: force behavior.
      print_orientation:
        Print orientation decision for debugging.

    Returns fitted pca for reuse across images.
    """
    meta = getattr(emb, "meta", {})
    if title is None:
        title = meta.get("model", "embedding PCA")

    if pca is None:
        pca = fit_pca_rgb(emb, n_samples=n_samples, seed=seed)

    rgb = transform_pca_rgb(emb, pca, robust_lo=robust_lo, robust_hi=robust_hi)
    auto_flipud, flip_reason = _infer_should_flipud_from_meta(meta)
    do_flipud = auto_flipud if flipud is None else bool(flipud)
    if do_flipud:
        rgb = np.flipud(rgb)

    if print_orientation:
        mode = "auto" if flipud is None else "manual"
        print(f"[{title}] flipud={do_flipud} ({mode}: {flip_reason})")

    plt.figure(figsize=figsize)
    plt.imshow(rgb)
    plt.title(title)
    plt.axis("off")
    plt.show()

    if show_colorbars:
        # Optional: also show the three PCA channels as grayscale for debugging
        data = getattr(emb, "data", emb)
        dhw = _to_dhw(data)
        D, H, W = dhw.shape
        X = dhw.reshape(D, H * W).T
        Xc = X - pca["mean"]
        Y = Xc @ pca["components"].T
        for k in range(3):
            img = _robust_scale01(Y[:, k], lo=robust_lo, hi=robust_hi).reshape(H, W)
            if do_flipud:
                img = np.flipud(img)
            plt.figure(figsize=figsize)
            plt.imshow(img)
            plt.title(f"{title} | PC{k+1}")
            plt.axis("off")
            plt.show()
    plt.savefig(f"{title.replace(' ','_')}_pca.png")
    return pca

def percentile_stretch(rgb_hwc: np.ndarray, p_low=1.0, p_high=99.0, gamma=1.0) -> np.ndarray:
    """Per-channel percentile stretch to [0,1]."""
    rgb = rgb_hwc.astype(np.float32)
    rgb = np.nan_to_num(rgb, nan=0.0, posinf=0.0, neginf=0.0)

    out = np.empty_like(rgb)
    for c in range(3):
        lo = np.percentile(rgb[..., c], p_low)
        hi = np.percentile(rgb[..., c], p_high)
        if hi <= lo + 1e-6:
            out[..., c] = 0.0
        else:
            out[..., c] = (rgb[..., c] - lo) / (hi - lo)
    out = np.clip(out, 0.0, 1.0)
    if gamma != 1.0:
        out = out ** (1.0 / gamma)
    return out


def show_input_chw(x_chw: np.ndarray, title: str, rgb_idx=(0, 1, 2), p_low=1, p_high=99):
    """Visualize CHW input. If C>=3 show RGB via indices; else show grayscale."""
    if x_chw.ndim != 3:
        print(f"Skip {title}: expected CHW, got shape={x_chw.shape}")
        return

    c, h, w = x_chw.shape
    print(f"{title:40s} shape={x_chw.shape} dtype={x_chw.dtype} min={x_chw.min():.3g} max={x_chw.max():.3g}")

    plt.figure(figsize=(6, 6))
    if c >= 3:
        r, g, b = rgb_idx
        if max(rgb_idx) >= c:
            raise ValueError(f"rgb_idx={rgb_idx} out of range for C={c}")

        rgb = np.stack([x_chw[r], x_chw[g], x_chw[b]], axis=-1)  # HWC
        rgb = percentile_stretch(rgb, p_low=p_low, p_high=p_high, gamma=1.0)
        plt.imshow(rgb)
    else:
        plt.imshow(x_chw[0], cmap="gray")

    plt.title(f"{title}  (C={c}, H={h}, W={w})")
    plt.axis("off")
    plt.show()


def print_band_quantiles_preview(report: dict, n_preview: int = 3):
    """Print a compact preview for report['band_quantiles']."""
    band_q = (report or {}).get("band_quantiles")
    if not band_q:
        print("band_quantiles not available")
        return
    preview = {k: v[:n_preview] for k, v in band_q.items()}
    print(f"band_quantiles (first {n_preview} bins):")
    print(preview)


def plot_histogram_from_report(report: dict, band_index: int = 0, figsize=(6, 3)):
    """Plot histogram for one band from inspect_gee_patch report."""
    hist = (report or {}).get("hist")
    if not hist or not hist.get("bins") or not hist.get("counts"):
        print("histogram not available")
        return

    bins = hist["bins"]
    counts = hist["counts"][band_index]
    plt.figure(figsize=figsize)
    plt.bar(bins[:-1], counts, width=bins[1] - bins[0], align="edge")
    plt.title(f"Band {band_index} histogram")
    plt.xlabel("DN")
    plt.ylabel("Count")
    plt.show()


def show_quicklook_artifact(
    artifacts: dict,
    *,
    flipud: bool = True,
    figsize=(3.5, 3.5),
    title: str = "quicklook_rgb",
):
    """Display quicklook image from inspect_gee_patch artifacts."""
    quicklook_path = (artifacts or {}).get("quicklook_rgb")
    if not quicklook_path:
        print("quicklook not saved; artifacts:", artifacts)
        return
    try:
        from pathlib import Path
    except Exception:
        print("pathlib is not available")
        return

    if Path(quicklook_path).exists():
        try:
            img = plt.imread(quicklook_path)
        except Exception as e:
            print(f"failed to read quicklook image: {e!r}")
            print("quicklook path:", quicklook_path)
            return

        if bool(flipud):
            img = np.flipud(img)

        plt.figure(figsize=figsize)
        plt.imshow(img)
        plt.title(title)
        plt.axis("off")
        plt.show()
    else:
        print("quicklook not found on disk:", quicklook_path)


def infer_rgb_idx_from_sensor(sensor_meta, channels: int):
    """Infer RGB channel indices from sensor metadata when possible."""
    if channels < 3:
        return None

    bands = []
    if isinstance(sensor_meta, dict):
        bands = [str(b).upper() for b in (sensor_meta.get("bands") or [])]

    if bands:
        idx = {b: i for i, b in enumerate(bands)}
        if all(k in idx for k in ("B4", "B3", "B2")):
            return (idx["B4"], idx["B3"], idx["B2"])
        if all(k in idx for k in ("RED", "GREEN", "BLUE")):
            return (idx["RED"], idx["GREEN"], idx["BLUE"])

    return (0, 1, 2)


def visualize_manifest_inputs(manifest: dict, npz_obj, p_low: float = 1, p_high: float = 99):
    """Visualize exact model inputs using manifest.models[*].input.npz_key."""
    models = (manifest or {}).get("models") or []
    by_key = defaultdict(list)
    sensor_for_key = {}

    for m in models:
        model_name = m.get("model", "<unknown>")
        input_meta = m.get("input") or {}
        key = input_meta.get("npz_key")
        if not key:
            print(f"[skip] {model_name}: no saved input")
            continue
        by_key[key].append(model_name)
        sensor_for_key.setdefault(key, m.get("sensor") or {})

    if not by_key:
        print("No model inputs found in manifest.models[*].input.npz_key")
        return

    npz_keys = set(npz_obj.files) if hasattr(npz_obj, "files") else set(npz_obj.keys())
    print("\n=== Visualizing exact model inputs ===")
    for key, model_names in by_key.items():
        if key not in npz_keys:
            print(f"[missing] {key} not found in NPZ")
            continue

        x = npz_obj[key]
        c = int(x.shape[0]) if getattr(x, "ndim", 0) == 3 else 0
        rgb_idx = infer_rgb_idx_from_sensor(sensor_for_key.get(key), c)
        title = f"{key} <- {', '.join(model_names)}"

        if rgb_idx is None:
            show_input_chw(x, title=title, p_low=p_low, p_high=p_high)
        else:
            show_input_chw(x, title=title, rgb_idx=rgb_idx, p_low=p_low, p_high=p_high)


def load_export_npz(npz_path, json_path=None):
    """Load exported NPZ + sidecar manifest JSON."""
    npz_path = Path(npz_path)
    json_path = Path(json_path) if json_path is not None else npz_path.with_suffix(".json")

    if not npz_path.exists():
        raise FileNotFoundError(f"Missing: {npz_path}")
    if not json_path.exists():
        raise FileNotFoundError(f"Missing: {json_path}")

    z = np.load(npz_path)
    with open(json_path, "r", encoding="utf-8") as f:
        manifest = json.load(f)
    return manifest, z


def print_export_summary(manifest: dict, npz_obj=None):
    """Print concise export summary from manifest."""
    print("=== Manifest summary ===")
    print("npz_path:", manifest.get("npz_path"))
    print("backend:", manifest.get("backend"))
    print("spatial:", manifest.get("spatial"))
    print("temporal:", manifest.get("temporal"))
    if npz_obj is not None:
        print("npz_keys:", getattr(npz_obj, "files", None))

    models = manifest.get("models") or []
    print("\n=== model -> input key ===")
    for m in models:
        model_name = m.get("model")
        input_meta = m.get("input") or {}
        print(f"{model_name}: {input_meta.get('npz_key')}")


def inspect_export_npz(npz_path, json_path=None, p_low: float = 1, p_high: float = 99):
    """One-call helper: load export, print summary, visualize exact model inputs."""
    manifest, z = load_export_npz(npz_path=npz_path, json_path=json_path)
    print_export_summary(manifest, z)
    visualize_manifest_inputs(manifest, z, p_low=p_low, p_high=p_high)

    artifacts = manifest.get("artifacts") or {}
    if artifacts:
        print("\n=== Artifacts ===")
        print(json.dumps(artifacts, ensure_ascii=False, indent=2))

    return manifest, z
